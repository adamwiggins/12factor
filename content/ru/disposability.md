## IX. Утилизируемость (Disposability)
### Максимизируйте надёжность с помощью быстрого запуска и корректного завершения работы

**[Процессы](./processes) приложения двенадцати факторов являются *утилизируемыми*, это означает, что они могут быть запущены и остановлены в любой момент.** Это способствует стабильному и гибкому масштабированию, быстрому развёртыванию изменений [кода](./codebase) и [конфигураций](./config) и надёжности рабочего развёртывания.

Процессы должны стараться **минимизировать время запуска**. В идеале процесс должен затратить всего несколько секунд от момента времени, когда выполнена команда запуска, и до того момента, когда процесс запущен и готов принимать запросы или задачи. Короткое время запуска предоставляет большую гибкость для [релиза](./build-release-run) и масштабирования. Кроме того, это более надёжно, так как менеджер процессов может свободно перемещать процессы на новые физические машины при необходимости.

Процессы должны **завершаться корректно, когда они получают [SIGTERM](http://en.wikipedia.org/wiki/SIGTERM)** сигнал от диспетчера процессов. Для веб-процесса корректное завершение работы достигается путём прекращения прослушивания порта сервиса (таким образом, отказаться от каких-либо новых запросов), что позволяет завершить текущие запросы и затем завершиться. В этой модели подразумевается, что HTTP-запросы короткие (не более чем на несколько секунд), в случае длинных запросов клиент должен плавно попытаться восстановить подключение при потере соединения.

Для процесса, выполняющего фоновые задачи (worker), корректное завершение работы достигается путём возвращения текущей задачи назад в очередь задач. Например, в [RabbitMQ](http://www.rabbitmq.com/) рабочий процесс может отправлять команду [`NACK`](http://www.rabbitmq.com/amqp-0-9-1-quickref.html#basic.nack); в [Beanstalkd](https://beanstalkd.github.io) задача возвращается в очередь автоматически, когда рабочий процесс отключается. Системы, основанные на блокировках такие, как [Delayed Job](https://github.com/collectiveidea/delayed_job#readme) должны быть уведомлены, чтобы освободить блокировку задачи. В этой модели подразумевается, что все задачи являются [повторно входимыми](http://en.wikipedia.org/wiki/Reentrant_%28subroutine%29), что обычно достигается путём оборачивания результатов работы в транзакции или путём использования [идемпотентных](http://en.wikipedia.org/wiki/Idempotence) операций.

Процессы также должны быть **устойчивыми к внезапной смерти** в случае отказа аппаратного обеспечения. Хотя это менее вероятное событие, чем корректное завершение работы сигналом `SIGTERM`, оно всё же может случиться. Рекомендуемым подходом является использование надёжных очередей задач, таких как Beanstalkd, которые возвращают задачу в очередь когда клиент отключается или превышает лимит времени. В любом случае приложение двенадцати факторов должно проектироваться так, чтобы обрабатывать неожиданные и неизящные выключения. [Архитектура только аварийного выключения (Crash-only design)](http://lwn.net/Articles/191059/) доводит эту концепцию до её [логического завершения](http://docs.couchdb.org/en/latest/intro/overview.html).
