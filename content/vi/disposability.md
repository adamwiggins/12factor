## IX. Tính khả dụng
### Tối ưu hoá với khởi động nhanh và dừng phần mềm ổn định

**[Tiến trình](./processes) của ứng dụng áp dụng mười hai thừa số luôn *sẵn sàng* (disposable), có nghĩa là bạn có thể chạy hoặc dừng phần mềm tại một thời điểm báo trước.** Điều này tạo điều kiện cho việc mở rộng trở nên dễ dàng hơn, việc triển khai nhanh các thay đổi của [mã nguồn](./codebase) hoặc [cấu hình](./config), và sự linh hoạt quá trình triển khai sản phẩm.

Các tiến trình nên cố gắng **giảm thiểu thời gian khởi động**. Lý tưởng nhất, một tiến trình chỉ cần một vài giây kể từ khi có lệnh khởi động cho đến khi tiến trình bắt đầu và sẵn sàng để nhận yêu cầu hay bắt đầu công việc. Thời gian khởi động ngắn cho phép quá trình triển khai và mở rộng nhanh hơn; và hỗ trợ mạnh mẽ hơn, vì hệ thống quản lý các tiến trình có thể dễ dàng mang các tiến trình tới các máy chủ vật lý khi có các cảnh báo.

Tiến trình **ngưng hoạt động linh hoạt khi chúng nhận được một tín hiệu [SIGTERM](http://en.wikipedia.org/wiki/SIGTERM)** từ hệ thống quản lý các tiến trình. Đối với ứng dụng web, việc ngưng hoạt động linh hoạt rất dễ thực hiện bằng cách ngừng lắng nghe trên công dịch vụ (do đó từ chối bất kỳ một yêu cầu mới nào), cho phép các yêu cầu hiện tại được kết thúc, và thoát ra. Ý tưởng của mô hình này là các yêu cầu HTTP cần thực hiện trong thời gian ngắn (thông thường không quá một vài giây), hoặc trong trường hợp kết nối lâu hơn, ứng dụng cần thực hiện kết nối lại khi các kết nối đã bị mất. 

Đối với các tiến trình thực thi, việc ngưng hoạt động linh hoạt có thể đạt được bằng cách trả các công việc trở lại hàng đợi. Ví dụ, trên [RabbitMQ](http://www.rabbitmq.com/) các tiến trình thực thi chỉ cần gửi lại một [`NACK`](http://www.rabbitmq.com/amqp-0-9-1-quickref.html#basic.nack); trên [Beanstalkd](http://kr.github.com/beanstalkd/), các công việc được trả lại hàng đợi tự động khi mà các tiến trình thực thi bị mất kết nối. Hệ thống sử dụng khoá như là [Delayed Job](https://github.com/collectiveidea/delayed_job#readme) cần đảm bảo sẽ giải phóng các bản ghi công việc. Ý tưởng của mô hình này là tất các các công việc cần [có khả năng quay lại][reentrant](http://en.wikipedia.org/wiki/Reentrant_%28subroutine%29), thường đạt đường bằng cách đóng gói các kết quả thành các giao dịch, hoặc tạo ra các toán tử [không thay đổi kết quả nếu đầu vào không thay đổi dù gọi một hay nhiều lần (idempotent)](http://en.wikipedia.org/wiki/Idempotence).

Các tiến trình cũng **có khả năng chống lại các lỗi bất thường**, như các thiết bị phần cứng đột nhiên ngừng hoạt động. Điều này thường ít khi xảy ra hơn là việc ngừng hoạt động linh hoạt với tín hiệu `SIGTERM`, nhưng vẫn có khả năng xảy ra. Cách tiếp cận thường được khuyến nghị là sử dụng cơ chế hàng đợi đằng sau, như là Beanstalkd, các công việc quay trở lại hàng đợi khi mà các kết nối bị ngừng hoặc quá hạn thời gian. Ngoài ra, ứng dụng sử dụng mười hai hệ số được thiết kế để có thể điều khiển các trường hợp ngừng hoạt động đột ngột, ép buộc. [Thiết kế chỉ có đổ vỡ] đem khái niệm này vào [các kết luận logic]](http://docs.couchdb.org/en/latest/intro/overview.html) của nó.
