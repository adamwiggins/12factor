## X. 開発/本番一致
### 開発、ステージング、本番環境をできるだけ一致させた状態を保つ

歴史的に、開発環境（開発者が直接変更するアプリケーションのローカル[デプロイ](./codebase)）と本番環境（エンドユーザーからアクセスされるアプリケーションの実行中デプロイ）の間には大きなギャップがあった。これらのギャップは3つの領域で現れる。

* **時間のギャップ**: 開発者が編集したコードが本番に反映されるまで数日、数週間、時には数ヶ月かかることがある。
* **人材のギャップ**: 開発者が書いたコードを、インフラエンジニアがデプロイする。
* **ツールのギャップ**: 本番デプロイではApache、MySQL、Linuxを使うのに、開発者がNginx、SQLite、OS Xのようなスタックを使うことがある。

**Twelve-Factor Appでは、[継続的デプロイ](http://avc.com/2011/02/continuous-deployment/)しやすいよう開発環境と本番環境のギャップを小さく保つ。** 上で述べた3つのギャップを見る。

* 時間のギャップを小さくする: 開発者が書いたコードは数時間後、さらには数分後にはデプロイされる。
* 人材のギャップを小さくする: コードを書いた開発者はそのコードのデプロイに深く関わり、そのコードの本番環境での挙動をモニタリングする。
* ツールのギャップを小さくする: 開発環境と本番環境をできるだけ一致させた状態を保つ。

上で述べたことを表にまとめる。

<table>
  <tr>
    <th></th>
    <th>伝統的なアプリケーション</th>
    <th>Twelve-Factor App</th>
  </tr>
  <tr>
    <th>デプロイの間隔</th>
    <td>数週間</td>
    <td>数時間</td>
  </tr>
  <tr>
    <th>コードを書く人とデプロイする人</th>
    <td>異なる人</td>
    <td>同じ人</td>
  </tr>
  <tr>
    <th>開発環境と本番環境</th>
    <td>異なる</td>
    <td>できるだけ一致</td>
  </tr>
</table>


[バックエンドサービス](./backing-services)（アプリケーションのデータベース、キューイングシステム、キャッシュなど）は、開発/本番一致が重要になる領域の一つである。多くの言語は、異なる種類のサービスへの *アダプター* を含め、バックエンド・サービスへのアクセスを単純化するライブラリを提供している。以下の表にいくつかの例を示す。


<table>
  <tr>
    <th>種類</th>
    <th>言語</th>
    <th>ライブラリ</th>
    <th>アダプター</th>
  </tr>
  <tr>
    <td>データベース</td>
    <td>Ruby/Rails</td>
    <td>ActiveRecord</td>
    <td>MySQL, PostgreSQL, SQLite</td>
  </tr>
  <tr>
    <td>キュー</td>
    <td>Python/Django</td>
    <td>Celery</td>
    <td>RabbitMQ, Beanstalkd, Redis</td>
  </tr>
  <tr>
    <td>キャッシュ</td>
    <td>Ruby/Rails</td>
    <td>ActiveSupport::Cache</td>
    <td>メモリ, ファイルシステム, Memcached</td>
  </tr>
</table>

本番環境ではより本格的で堅牢なバックエンドサービスが使われるにもかかわらず、開発者は自身のローカル開発環境で軽量なバックエンドサービスを使いたくなることがある。例えば、開発環境ではSQLiteを使い、本番ではPostgreSQLを使ったり、開発環境ではローカルプロセスのメモリをキャッシュに使い、本番ではMemcachedを使ったりするなどである。

たとえ理論的にはアダプターがバックエンドサービスの違いをすべて抽象化してくれるとしても、 **Twelve-Factorの開発者は、開発と本番の間で異なるバックエンドサービスを使いたくなる衝動に抵抗する。** バックエンドサービスの違いは、わずかな非互換性が顕在化し、開発環境やステージング環境では正常に動作してテストも通過するコードが本番環境でエラーを起こす事態を招くことを意味する。この種のエラーは継続的デプロイを妨げる摩擦を生む。この摩擦とそれに伴って継続的デプロイが妨げられることのコストは、アプリケーションのライフサイクルに渡ってトータルで考えると非常に高くつく。

軽量なローカルサービスは、以前ほど魅力的なものではなくなっている。Memcached、PostgreSQLやRabbitMQなどのモダンなバックエンドサービスは、[Homebrew](http://mxcl.github.com/homebrew/) や [apt-get](https://help.ubuntu.com/community/AptGet/Howto) などのモダンなパッケージングシステムのおかげで、簡単にインストールして実行できる。あるいは [Chef](http://www.opscode.com/chef/) や [Puppet](http://docs.puppetlabs.com/) などの宣言的なプロビジョニングツールと、[Vagrant](http://vagrantup.com/) などの軽量な仮想環境を組み合わせることで、開発者は本番環境に限りなく近いローカル環境を作ることができる。開発/本番一致と継続的デプロイの利益に比べると、これらのシステムをインストールして利用するコストは低い。

異なるバックエンドサービスへのアダプターは依然有用である。これらのアダプターは、新しいバックエンドサービスに移植するときの苦痛を比較的和らげてくれるためである。しかし、アプリケーションのすべてのデプロイ（開発、ステージング、本番環境）は同じ種類かつ同じバージョンのバックエンドサービスを利用するべきである。
