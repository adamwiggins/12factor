## IX. İmha edilebilirlik
### Hızlı başlangıç ve zararsız sonlanma ile maksimum servis sağlığı

**On iki faktör uygulamalarının [süreçleri](./processes) *tek kullanımlıktır*, yani anlık olarak başlatılabilir ve durdurulabilirler.** Bu hızlı esnek ölçeklemeyi, [kod](./codebase) ve [yapılandırma](./config) değişikliklerinin hızlı dağıtımı ve canlı yayın dağıtımlarının sağlamlığını arttırır.

Süreçler **başlangıç zamanını küçültmeye** çabalamalıdır. İdeal olarak, bir sürecin başlatma komutunun çalıştırılmasından, sürecin ayağa kalkmış ve istek/işleri karşılamaya hazır hale gelmesine kadar olan süre birkaç saniyedir. Kısa başlama zamanı [yayınlama](./build-release-run) süreci ve ölçeklenme için daha fazla çeviklik sağlar; ve sağlamlığına yardımcı olur, çünkü süreç yöneticisi süreçleri yeni fiziksel makinelere daha kolay taşıyabilir.

Süreçler, süreç yöneticisinden **[SIGTERM](http://en.wikipedia.org/wiki/SIGTERM) sinyalini aldıkları zaman, kontrollü şekilde kapanırlar.** Bir web süreci için kontrollü kapama, servis portunun dinlenmesinin kesilmesi (dolayısıyla herhangi bir yeni istek reddedilir), eğer varsa o an işleniyor olan isteğin tamamlanmasına izin verilmesi ve daha sonra sürecin sonlandırılması şeklinde gerçekleşir. Bu modelin içeriğinde HTTP istekleri kısadır (birkaç saniyeden fazla değildir) veya uzun sorgulama durumlarında, istemci bağlantıyı kaybettiği zaman sorunsuzca tekrar bağlanmayı denemelidir.

Bir işçi süreç için kontrollü kapama, güncel işin iş kuyruğuna döndürülmesiyle sonuçlanır. Örneğin [RabbitMQ](http://www.rabbitmq.com/)'da işçi [`NACK`](http://www.rabbitmq.com/amqp-0-9-1-quickref.html#basic.nack) sinyali gönderebilir; [Beanstalkd](https://beanstalkd.github.io)'da herhangi bir zamanda işçi süreç bağlantıyı kopardığında iş kuyruğa otomatik olarak döndürülür. Kilit tabanlı sistemler, [Delayed Job](https://github.com/collectiveidea/delayed_job#readme) gibi, üzerinde çalışıyor oldukları işin kilitlerini kaldırdıklarından emin olmalıdır. Bu modelin içeriğinde bütün işler [tekrar girişli](http://en.wikipedia.org/wiki/Reentrant_%28subroutine%29)dir, genellikle sonuçların bir transaksiyonda (İng. transaction) saklanması veya süreci [eşgüçlü](http://en.wikipedia.org/wiki/Idempotence) yapmasıyla gerçekleşir.

Süreçler, donanımsal sorun oluşması gibi durumlarda oluşacak **ani sonlanmalara karşı dayanıklı olmalıdır.** Bu `SIGTERM` ile kontrollü kapamadan daha az yaygın bir olaydır, ancak yine de gerçekleşebilir. Önerilen yaklaşım, Beanstalkd gibi sağlam arkaplan kuyruklama sistemlerinin kullanımıdır. Bu sistemler, istemciler oturumu kapattığı zaman veya süre aşımı durumlarında işi kuyruğa döndürür. Her iki durumda, on iki faktör uygulaması kontrollü olmayan sonlandırmaları idare edebilmek için tasarlanmıştır. [Crash-only tasarım](http://lwn.net/Articles/191059/) bu konsepti [mantıksal sonucu](http://docs.couchdb.org/en/latest/intro/overview.html)na ulaştırır.
